from __future__ import annotations

from typing import Any, Optional, Collection, Union, Callable, IO, TypeVar

_Length = Union[int, ContextLambda, slice, Ellipsis]

DefaultOption: DefaultOptionType = ...
FIELD_OPTIONS: set = ...
F_DYNAMIC: Option = ...
F_SEQUENTIAL: Option = ...
HOST_ARCH: Arch = ...
InvalidDefault: InvalidDefaultType = ...
NATIVE_ENDIAN: Endian = ...
LITTLE_ENDIAN: Endian = ...
BIG_ENDIAN: Endian = ...
STRUCT_OPTIONS: set = ...
S_DISCARD_CONST: Option = ...
S_DISCARD_UNNAMED: Option = ...
S_EVAL_ANNOTATIONS: Option = ...
S_REPLACE_TYPES: Option = ...
S_SLOTS: Option = ...
S_UNION: Option = ...

class Context(dict):
    def __init__(self, *args, **kwargs) -> None: ...
    def __context_getattr__(self, *args, **kwargs): ...

ContextLambda = Callable[[Context], Any]

class Arch:
    name: str
    ptr_size: int
    def __init__(self, name: str, ptr_size: int) -> None: ...
    def __hash__(self) -> int: ...

class BinaryExpr:
    expr: int
    lhs: Union[ContextLambda, Any]
    rhs: Union[ContextLambda, Any]
    def __init__(self, *args, **kwargs) -> None: ...
    def __call__(self, *args, **kwargs): ...

class ContextPath:
    path: str
    def __init__(self, path: str) -> None: ...
    def __add__(self, other) -> BinaryExpr: ...
    def __and__(self, other) -> BinaryExpr: ...
    def __call__(self, context: Context) -> Any: ...
    def __eq__(self, other: object) -> BinaryExpr: ...
    def __floordiv__(self, other) -> BinaryExpr: ...
    def __ge__(self, other: object) -> BinaryExpr: ...
    def __gt__(self, other: object) -> BinaryExpr: ...
    def __hash__(self) -> int: ...
    def __invert__(self) -> UnaryExpr: ...
    def __le__(self, other: object) -> BinaryExpr: ...
    def __lshift__(self, other) -> BinaryExpr: ...
    def __lt__(self, other: object) -> BinaryExpr: ...
    def __mod__(self, other) -> BinaryExpr: ...
    def __mul__(self, other) -> BinaryExpr: ...
    def __ne__(self, other: object) -> BinaryExpr: ...
    def __neg__(self) -> UnaryExpr: ...
    def __or__(self, other) -> BinaryExpr: ...
    def __sub__(self, other) -> UnaryExpr: ...
    def __truediv__(self, other) -> BinaryExpr: ...
    def __type__(self) -> type: ...
    def __xor__(self, other) -> BinaryExpr: ...

class DefaultOptionType:
    def __init__(self) -> None: ...

class Endian:
    ch: str
    name: str
    def __init__(self, ch: str, name: str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class atom:
    def __init__(self) -> None: ...
    def __pack__(self, obj: Any, context: Context) -> None: ...
    def __size__(self, context: Context) -> Any: ...
    def __type__(self) -> Any: ...
    def __unpack__(self, context: Context) -> Any: ...

class catom(atom):
    def __init__(self) -> None: ...
    def __pack__(self, obj: Any, context: Context) -> None: ...
    def __pack_many__(self, obj: Collection[Any], context: Context) -> None: ...
    def __size__(self, context: Context) -> Any: ...
    def __type__(self) -> Any: ...
    def __unpack__(self, context: Context) -> Any: ...
    def __unpack_many__(self, context: Context) -> Collection[Any]: ...

class builtinatom(catom):
    def __init__(self, *args, **kwargs) -> None: ...
    def __floordiv__(self, other) -> condition: ...
    def __getitem__(self, index) -> repeated: ...
    def __matmul__(self, *args, **kwargs) -> atoffset: ...
    def __rfloordiv__(self, other) -> condition: ...
    def __rmatmul__(self, *args, **kwargs) -> atoffset: ...
    def __rrshift__(self, other) -> switch: ...
    def __rshift__(self, other) -> switch: ...


class char_t(builtinatom):
    def __init__(self, *args, **kwargs) -> None: ...

class condition(builtinatom):
    atom: Any
    condition: Union[bool, ContextLambda]
    def __init__(self, *args, **kwargs) -> None: ...
    def is_enabled(self, *args, **kwargs): ...
    def __set_byteorder__(self, *args, **kwargs): ...

class const_t(builtinatom):
    def __init__(self, *args, **kwargs) -> None: ...


class fieldatom(atom):
    def __init__(self) -> None: ...
    def __add__(self, endian: Endian) -> Field: ...
    def __floordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __getitem__(
        self, length: _Length
    ) -> Field: ...
    def __matmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __or__(self, option: Option) -> Field: ...
    def __radd__(self, endian: Endian) -> Field: ...
    def __rfloordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __rmatmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __ror__(self, option: Option) -> Field: ...
    def __rrshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rxor__(self, option: Option) -> Field: ...
    def __xor__(self, option: Option) -> Field: ...

class fieldcatom(catom):
    def __init__(self) -> None: ...
    def __add__(self, endian: Endian) -> Field: ...
    def __floordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __getitem__(
        self, length: _Length
    ) -> Field: ...
    def __matmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __or__(self, option: Option) -> Field: ...
    def __radd__(self, endian: Endian) -> Field: ...
    def __rfloordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __rmatmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __ror__(self, option: Option) -> Field: ...
    def __rrshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rxor__(self, option: Option) -> Field: ...
    def __xor__(self, option: Option) -> Field: ...

class Field:
    arch: Arch
    atom: atom
    condition: Union[bool, ContextLambda]
    default: Union[Any, InvalidDefaultType]
    endian: Endian
    length: _Length
    name: str
    offset: Union[ContextLambda, int]
    options: set[Option]
    switch: Union[dict, ContextLambda]
    def __init__(
        self,
        atom: atom,
        name: str = ...,
        endian: Endian = ...,
        offset: Union[ContextLambda, int] = ...,
        arch: Arch = ...,
        length: _Length = ...,
        default: Union[Any, InvalidDefaultType] = ...,
        switch: Union[dict, ContextLambda] = ...,
        options: set[Option] = ...,
        condition: Union[bool, ContextLambda] = ...,
    ) -> None: ...
    def __add__(self, endian: Endian) -> Field: ...
    def __floordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __getitem__(
        self, length: _Length
    ) -> Field: ...
    def __matmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __or__(self, option: Option) -> Field: ...
    def __radd__(self, endian: Endian) -> Field: ...
    def __rfloordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __rmatmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __ror__(self, option: Option) -> Field: ...
    def __rrshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rxor__(self, option: Option) -> Field: ...
    def __xor__(self, option: Option) -> Field: ...

class InvalidDefaultType:
    def __init__(self) -> None: ...

class Option:
    name: str
    value: Optional[Any]
    def __init__(self, name: str, value: Optional[Any] = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class State:
    globals: Context
    io: IO
    offset_table: dict
    def __init__(self, io: IO, **globals) -> None: ...
    def read(self, __n: int) -> bytes: ...
    def seek(self, __offset: int, __whence: int = ...) -> None: ...
    def tell(self) -> int: ...
    def write(self, __data: bytes) -> None: ...

class fieldinfo:
    excluded: bool
    field: atom
    def __init__(self, field: atom, excluded: bool = ...) -> None: ...

class Struct(builtinatom):
    members: dict[str, fieldinfo]
    model: type
    options: set[Option]
    def __init__(
        self,
        model: type,
        options: set[Option] = ...,
        endian: Endian = ...,
        field_options: set[Option] = ...,
        alter_model: bool = ...,
    ) -> None: ...

class UnaryExpr:
    expr: int
    value: Union[ContextLambda, Any]
    def __init__(self, expr: int, value: Union[ContextLambda, Any]) -> Any: ...
    def __call__(self, *args, **kwargs): ...
    def __hash__(self) -> int: ...

class layer:
    field: Field
    greedy: bool
    index: int
    length: int
    obj: Context
    parent: layer
    path: str
    sequence: Collection
    sequential: bool
    state: State
    value: Any
    def __init__(
        self,
        state: State,
        field: Field = ...,
        obj: Context = ...,
        value: Any = ...,
        path: str = ...,
        sequence: Collection = ...,
        parent: layer = ...,
    ) -> None: ...
    def __context_getattr__(self, path: str) -> Any: ...

def typeof(obj: atom): ...
def pack_into(__obj: Any, __struct: atom, __io: IO, **globals) -> None: ...
def pack(__obj: Any, __struct: atom, **globals) -> bytes: ...
def sizeof(obj: atom, globals: Optional[dict | Context] = ...): ...
def unpack(__io: Any, __struct: atom, **globals) -> Any: ...

class int_t(fieldcatom):
    little_endian: bool
    nbits: int
    nbytes: int
    signed: bool
    def __init__(self, nbits: int, signed: bool = ..., little_endian: bool = ...) -> None: ...

i16: int_t
i24: int_t
i32: int_t
i64: int_t
i8: int_t
u16: int_t
u24: int_t
u32: int_t
u64: int_t
u8: int_t

class float_t(fieldcatom):
    little_endian: bool
    nbits: int
    nbytes: int
    def __init__(self, nbits: int, little_endian: bool = ...) -> None: ...

f16: float_t
f32: float_t
f64: float_t

class padding_t(fieldcatom):
    def __init__(self, pad: int) -> None: ...

padding: padding_t

boolean: bool_t
char: char_t

class string(fieldcatom):
    encoding: str
    errors: str
    length: _Length
    def __init__(self, length: _Length, encoding: str, errors: str = ...) -> None: ...

class atoffset(builtinatom):
    offset: Union[int, ContextLambda]
    whence: int
    def __init__(self, *args, **kwargs) -> None: ...
    def get_offset(self, layer: layer) -> int: ...
    def __set_byteorder__(self, byteorder: Endian): ...


class objlayer(layer):
    obj: Context
    def __init__(self, *args, **kwargs) -> None: ...
    def __context_getattr__(self, *args, **kwargs): ...

class repeated(builtinatom):
    atom: Any
    length: _Length
    def __init__(self, *args, **kwargs) -> None: ...
    def __set_byteorder__(self, *args, **kwargs): ...

class seqlayer(layer):
    index: int
    length: int
    sequence: Collection
    def __init__(self, *args, **kwargs) -> None: ...

class switch(builtinatom):
    atom: Any
    cases: Union[dict[Any, Any], ContextLambda]
    def __init__(self, *args, **kwargs) -> None: ...
    def get_next(self, *args, **kwargs): ...
    def __set_byteorder__(self, *args, **kwargs): ...

from __future__ import annotations

from typing import Any, Optional, Collection, Union, Callable, IO, TypeVar
from enum import EnumType

_Length = Union[int, ContextLambda, slice, Ellipsis]
ContextLambda = Callable[[Context], Any]
_ConstType = Union[Any, ContextLambda]

BIG_ENDIAN: Endian
DefaultOption: DefaultOptionType
FIELD_OPTIONS: set
F_DYNAMIC: Option
F_SEQUENTIAL: Option
HOST_ARCH: Arch
InvalidDefault: InvalidDefaultType
LITTLE_ENDIAN: Endian
NATIVE_ENDIAN: Endian
STRUCT_OPTIONS: set
S_DISCARD_CONST: Option
S_DISCARD_UNNAMED: Option
S_EVAL_ANNOTATIONS: Option
S_REPLACE_TYPES: Option
S_SLOTS: Option
S_UNION: Option
boolean: Bool
char: Char
f16: Float
f32: Float
f64: Float
i128: Int
i16: Int
i24: Int
i32: Int
i64: Int
i8: Int
lsbvarint: VarInt
padding: Padding
u128: Int
u16: Int
u24: Int
u32: Int
u64: Int
u8: Int
varint: VarInt

class Context(dict):
    def __init__(self, /, **kwargs) -> None: ...
    def __context_getattr__(self, *args, **kwargs): ...

class Arch:
    name: str
    ptr_size: int
    def __init__(self, name: str, ptr_size: int) -> None: ...
    def __hash__(self) -> int: ...

class binaryexpr:
    expr: int
    lhs: Union[ContextLambda, Any]
    rhs: Union[ContextLambda, Any]
    def __init__(
        self,
        expr: int,
        left: Union[ContextLambda, Any],
        right: Union[ContextLambda, Any],
    ) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...

class ContextPath:
    path: str
    def __init__(self, path: str) -> None: ...
    def __add__(self, other) -> binaryexpr: ...
    def __and__(self, other) -> binaryexpr: ...
    def __call__(self, context: Context) -> Any: ...
    def __eq__(self, other: object) -> binaryexpr: ...
    def __floordiv__(self, other) -> binaryexpr: ...
    def __ge__(self, other: object) -> binaryexpr: ...
    def __gt__(self, other: object) -> binaryexpr: ...
    def __hash__(self) -> int: ...
    def __invert__(self) -> unaryexpr: ...
    def __le__(self, other: object) -> binaryexpr: ...
    def __lshift__(self, other) -> binaryexpr: ...
    def __lt__(self, other: object) -> binaryexpr: ...
    def __mod__(self, other) -> binaryexpr: ...
    def __mul__(self, other) -> binaryexpr: ...
    def __ne__(self, other: object) -> binaryexpr: ...
    def __neg__(self) -> unaryexpr: ...
    def __or__(self, other) -> binaryexpr: ...
    def __sub__(self, other) -> unaryexpr: ...
    def __truediv__(self, other) -> binaryexpr: ...
    def __type__(self) -> type: ...
    def __xor__(self, other) -> binaryexpr: ...

class DefaultOptionType:
    def __init__(self) -> None: ...

class Endian:
    ch: str
    name: str
    def __init__(self, ch: str, name: str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class atom:
    def __init__(self) -> None: ...
    def __pack__(self, obj: Any, context: layer) -> None: ...
    def __size__(self, context: layer) -> Any: ...
    def __type__(self) -> Any: ...
    def __unpack__(self, context: layer) -> Any: ...

class catom(atom):
    def __init__(self) -> None: ...
    def __pack__(self, obj: Any, context: layer) -> None: ...
    def __pack_many__(self, obj: Collection[Any], layer: layer) -> None: ...
    def __size__(self, context: layer) -> Any: ...
    def __type__(self) -> Any: ...
    def __unpack__(self, context: layer) -> Any: ...
    def __unpack_many__(self, context: layer, lengthinfo) -> Collection[Any]: ...

class builtinatom(catom):
    def __init__(self, *args, **kwargs) -> None: ...
    def __floordiv__(self, other) -> condition: ...
    def __getitem__(self, index) -> repeated: ...
    def __matmul__(self, *args, **kwargs) -> atoffset: ...
    def __rfloordiv__(self, other) -> condition: ...
    def __rmatmul__(self, *args, **kwargs) -> atoffset: ...
    def __rrshift__(self, other) -> switch: ...
    def __rshift__(self, other) -> switch: ...

class Char(builtinatom):
    def __init__(self, *args, **kwargs) -> None: ...

class condition(builtinatom):
    atom: Any
    condition: Union[bool, ContextLambda]
    def __init__(self, condition: Union[bool, ContextLambda], atom: Any) -> None: ...
    def is_enabled(self, context: layer) -> bool: ...
    def __set_byteorder__(self, byteorder: Endian) -> condition: ...

class const(builtinatom):
    def __init__(self, *args, **kwargs) -> None: ...

class builtinatom(catom):
    def __init__(self) -> None: ...
    def __add__(self, endian: Endian) -> Field: ...
    def __floordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __getitem__(self, length: _Length) -> Field: ...
    def __matmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __or__(self, option: Option) -> Field: ...
    def __radd__(self, endian: Endian) -> Field: ...
    def __rfloordiv__(self, condition: Union[bool, ContextLambda]) -> Field: ...
    def __rmatmul__(self, offset: Union[ContextLambda, int]) -> Field: ...
    def __ror__(self, option: Option) -> Field: ...
    def __rrshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rshift__(self, switch: Union[dict, ContextLambda]) -> Field: ...
    def __rxor__(self, option: Option) -> Field: ...
    def __xor__(self, option: Option) -> Field: ...

class InvalidDefaultType:
    def __init__(self) -> None: ...

class Option:
    name: str
    value: Optional[Any]
    def __init__(self, name: str, value: Optional[Any] = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class State:
    globals: Context
    io: IO
    offset_table: dict
    def __init__(self, io: IO, **globals) -> None: ...
    def read(self, __n: int) -> bytes: ...
    def seek(self, __offset: int, __whence: int = ...) -> None: ...
    def tell(self) -> int: ...
    def write(self, __data: bytes) -> None: ...

class fieldinfo:
    excluded: bool
    default: Any
    field: atom
    name: str
    def __init__(self, field: atom, excluded: bool = ...) -> None: ...

class lengthinfo:
    length: int
    greedy: bool
    def __init__(self, length: int = ..., greedy: bool = ...) -> None: ...

class Struct(builtinatom):
    members: dict[str, fieldinfo]
    model: type
    options: set[Option]
    def __init__(
        self,
        model: type,
        options: set[Option] = ...,
        endian: Endian = ...,
        field_options: set[Option] = ...,
        alter_model: bool = ...,
    ) -> None: ...

class unaryexpr:
    expr: int
    value: Union[ContextLambda, Any]
    def __init__(self, expr: int, value: Union[ContextLambda, Any]) -> Any: ...
    def __call__(self, *args, **kwargs): ...
    def __hash__(self) -> int: ...

class layer:
    field: Field
    greedy: bool
    index: int
    length: int
    obj: Context
    parent: layer
    path: str
    sequence: Collection
    sequential: bool
    state: State
    value: Any
    def __init__(
        self,
        state: State,
        field: Field = ...,
        obj: Context = ...,
        value: Any = ...,
        path: str = ...,
        sequence: Collection = ...,
        parent: layer = ...,
    ) -> None: ...
    def __context_getattr__(self, path: str) -> Any: ...

def typeof(obj: atom): ...
def pack_into(__obj: Any, __struct: atom, __io: IO, **globals) -> None: ...
def pack(__obj: Any, __struct: atom, **globals) -> bytes: ...
def sizeof(obj: atom, globals: Optional[dict | Context] = ...): ...
def unpack(__io: Any, __struct: atom, **globals) -> Any: ...

class Int(builtinatom):
    little_endian: bool
    nbits: int
    nbytes: int
    signed: bool
    def __init__(
        self, nbits: int, signed: bool = ..., little_endian: bool = ...
    ) -> None: ...

class Float(builtinatom):
    little_endian: bool
    nbits: int
    nbytes: int
    def __init__(self, nbits: int, little_endian: bool = ...) -> None: ...

class Padding(builtinatom):
    def __init__(self, pad: int) -> None: ...

class string(builtinatom):
    encoding: str
    errors: str
    length: _Length
    def __init__(self, length: _Length, encoding: str, errors: str = ...) -> None: ...

class atoffset(builtinatom):
    offset: Union[int, ContextLambda]
    whence: int
    def __init__(
        self, offset: Union[int, ContextLambda], atom: atom, whence: int = ...
    ) -> None: ...
    def get_offset(self, layer: layer) -> int: ...
    def __set_byteorder__(self, byteorder: Endian) -> atoffset: ...


class repeated(builtinatom):
    atom: Any
    length: _Length
    def __init__(self, atom: atom, length: _Length) -> None: ...
    def __set_byteorder__(self, byteorder: Endian) -> repeated: ...

class seqlayer(layer):
    index: int
    length: int
    sequence: Collection
    def __init__(self, *args, **kwargs) -> None: ...

class switch(builtinatom):
    atom: Any
    cases: Union[dict[Any, Any], ContextLambda]
    def __init__(
        self, atom: atom, cases: Union[dict[Any, Any], ContextLambda]
    ) -> None: ...
    def get_next(self, obj: Any, context: layer) -> Any: ...
    def __set_byteorder__(self, byteorder: Endian) -> switch: ...

class cstring(builtinatom):
    length: Union[_Length, atom]
    encoding: str
    errors: str
    terminator: str
    keep_terminator: bool

    def __init__(
        self,
        length: Union[_Length, atom],
        encoding: str = ...,
        errors: str = ...,
        sep: str = ...,
        keep_terminator: bool = ...,
    ) -> None: ...

class octetstring(builtinatom):
    length: _Length
    def __init__(self, length: _Length) -> None: ...

class enumeration(builtinatom):
    atom: Any
    enum_type: EnumType
    members: dict[Any, Any]
    default: Any
    def __init__(
        self,
        atom: atom,
        enum_type: EnumType,
        default: Any = ...,
    ) -> None: ...
    def __set_byteorder__(self, byteorder: Endian) -> enumeration: ...

class pstring(builtinatom):
    atom: Any
    encoding: str
    errors: str
    def __init__(self, atom: atom, encoding: str = ..., errors: str = ...) -> None: ...
    def __set_byteorder__(self, byteorder: Endian) -> pstring: ...

class VarInt(builtinatom):
    little_endian: bool
    lsb: bool
    def __init__(self, little_endian: bool = ..., lsb: bool = ...) -> None: ...
    def __set_byteorder__(self, byteorder: Endian) -> VarInt: ...

class computed(builtinatom):
    value: _ConstType
    def __init__(self, value: _ConstType) -> None: ...

class objlayer(layer):
    obj: Context
    def __init__(
        self, state: State, path: str = ..., parent: layer = ..., obj: Context = ...
    ) -> None: ...
    def __context_getattr__(self, path: str) -> Any: ...

class lazy(builtinatom):
    always_lazy: bool
    fn: Callable[[], atom]
    def __init__(self, fn: Callable[[], atom], always_lazy: bool = ...) -> None: ...
    def __set_byteorder__(self, byteorder: Endian) -> lazy: ...

class patom(atom):
    def __init__(self) -> None: ...
    def __floordiv__(self, other): ...
    def __getitem__(self, index): ...
    def __matmul__(self, *args, **kwargs): ...
    def __rfloordiv__(self, other): ...
    def __rmatmul__(self, *args, **kwargs): ...
    def __rrshift__(self, other): ...
    def __rshift__(self, other): ...

from _typeshed import Incomplete
from types import NotImplementedType
from typing import (
    IO,
    Any,
    Callable,
    Collection,
    Dict,
    Generic,
    Optional,
    Protocol,
    Type,
    TypeVar,
    Union,
)

from caterpillar.abc import (
    _IT,
    _OT,
    _ContextLike,
    _LengthT,
    _ContextLambdaReturnT_co,
    _ContextLambda,
)

class _CContextLambda(Protocol[_ContextLambdaReturnT_co]):
    def __call__(self, layer: layer) -> _ContextLambdaReturnT_co: ...

_CTypeDesc = Union[str, Type[_OT], NotImplementedType]

BIG_ENDIAN: Endian
DefaultOption: DefaultOptionType
FIELD_OPTIONS: set
F_DYNAMIC: Option
F_SEQUENTIAL: Option
HOST_ARCH: Arch
InvalidDefault: InvalidDefaultType
LITTLE_ENDIAN: Endian
NATIVE_ENDIAN: Endian
STRUCT_OPTIONS: set
S_DISCARD_CONST: Option
S_DISCARD_UNNAMED: Option
S_EVAL_ANNOTATIONS: Option
S_REPLACE_TYPES: Option
S_SLOTS: Option
S_UNION: Option
TYPE_MAP: dict
boolean: Bool
char: Char
f16: Float
f32: Float
f64: Float
i128: Int
i16: Int
i24: Int
i32: Int
i64: Int
i8: Int
lsbvarint: VarInt
padding: Padding
u128: Int
u16: Int
u24: Int
u32: Int
u64: Int
u8: Int
varint: VarInt

class Arch:
    name: str
    ptr_size: int
    def __init__(self, name: str, ptr_size: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Bool(builtinatom[bool, bool]):
    def __init__(self) -> None: ...

class Char(builtinatom[str, str]):
    def __init__(self) -> None: ...

class Context(dict, _ContextLike):
    def __init__(self, *args, **kwargs) -> None: ...
    def __context_getattr__(self, *args, **kwargs): ...
    def __getattribute__(self, name: str, /) -> Any: ...

class ContextPath(_ContextLambda):
    path: str
    def __init__(self, path: str) -> None: ...
    def __add__(self, other) -> binaryexpr: ...
    def __and__(self, other) -> binaryexpr: ...
    def __call__(self, context: _ContextLike): ...
    def __eq__(self, other: object) -> binaryexpr: ...
    def __floordiv__(self, other) -> binaryexpr: ...
    def __ge__(self, other: object) -> binaryexpr: ...
    def __gt__(self, other: object) -> binaryexpr: ...
    def __hash__(self) -> int: ...
    def __invert__(self) -> unaryexpr: ...
    def __le__(self, other: object) -> binaryexpr: ...
    def __lshift__(self, other) -> binaryexpr: ...
    def __lt__(self, other: object) -> binaryexpr: ...
    def __matmul__(self, *args, **kwargs) -> binaryexpr: ...
    def __mod__(self, other) -> binaryexpr: ...
    def __mul__(self, other) -> binaryexpr: ...
    def __ne__(self, other: object) -> binaryexpr: ...
    def __neg__(self) -> unaryexpr: ...
    def __or__(self, other) -> binaryexpr: ...
    def __pos__(self) -> unaryexpr: ...
    def __pow__(self, other) -> binaryexpr: ...
    def __radd__(self, other) -> binaryexpr: ...
    def __rand__(self, other) -> binaryexpr: ...
    def __rfloordiv__(self, other) -> binaryexpr: ...
    def __rlshift__(self, other) -> binaryexpr: ...
    def __rmatmul__(self, *args, **kwargs) -> binaryexpr: ...
    def __rmod__(self, other) -> binaryexpr: ...
    def __rmul__(self, other) -> binaryexpr: ...
    def __ror__(self, other) -> binaryexpr: ...
    def __rpow__(self, other) -> binaryexpr: ...
    def __rrshift__(self, other) -> binaryexpr: ...
    def __rshift__(self, other) -> binaryexpr: ...
    def __rsub__(self, other) -> binaryexpr: ...
    def __rtruediv__(self, other) -> binaryexpr: ...
    def __rxor__(self, other) -> binaryexpr: ...
    def __size__(self, layer: layer) -> int: ...
    def __sub__(self, other) -> binaryexpr: ...
    def __truediv__(self, other) -> binaryexpr: ...
    def __type__(self, layer: layer) -> _CTypeDesc: ...
    def __xor__(self, other): ...

class DefaultOptionType:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class Endian:
    ch: str
    name: str
    def __init__(self, ch: str, name: str) -> None: ...
    def __add__(self, other): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __radd__(self, other): ...

class Float(builtinatom[float, float]):
    little_endian: bool
    nbits: int
    nbytes: int
    def __init__(self, nbits: int, little_endian: bool = ...) -> None: ...
    def __set_byteorder__(self, endian: Endian) -> Float: ...

class Int(builtinatom[int, int]):
    little_endian: bool
    nbits: int
    nbytes: int
    signed: bool
    def __init__(
        self, nbits: int, signed: bool = ..., little_endian: bool = ...
    ) -> None: ...
    def __set_byteorder__(self, endian: Endian) -> Int: ...

class InvalidDefaultType:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

_OptionValueT = TypeVar("_OptionValueT", default=Any)

class Option(Generic[_OptionValueT]):
    name: str
    value: Optional[_OptionValueT]
    def __init__(self, name: str, value: Optional[_OptionValueT] = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Padding(builtinatom[None, None]):
    def __init__(self, pad: str) -> None: ...

class State:
    globals: Context
    io: IO
    offset_table: dict
    def __init__(self, io: Optional[IO] = ..., **globals) -> None: ...
    def read(self, __n: int) -> bytes: ...
    def seek(self, __offset: int, __whence: int = ...) -> None: ...
    def tell(self) -> int: ...
    def write(self, __data: bytes) -> None: ...

_ModelT = TypeVar("_ModelT")

class Struct(Generic[_ModelT], builtinatom[_ModelT, _ModelT]):
    members: dict[str, fieldinfo]
    model: Type[_ModelT]
    options: set[Option]
    def __init__(
        self,
        model: Type[_ModelT],
        options: set[Option] = ...,
        endian: Endian = ...,
        field_options: set[Option] = ...,
        alter_model: bool = ...,
    ) -> None: ...

class VarInt(builtinatom[int, int]):
    little_endian: Incomplete
    lsb: Incomplete
    def __init__(self, little_endian: bool = ..., lsb: bool = ...) -> None: ...
    def __set_byteorder__(self, endian: Endian) -> VarInt: ...

class atoffset(builtinatom[_IT, _OT]):
    offset: Union[int, _CContextLambda[int]]
    whence: int
    def __init__(
        self,
        offset: Union[int, _CContextLambda[int]],
        atom: atom[_IT, _OT],
        whence: int = ...,
    ) -> None: ...
    def get_offset(self, layer: layer) -> int: ...
    def __set_byteorder__(self, byteorder: Endian) -> atoffset: ...

class atom(Generic[_IT, _OT]):
    def __init__(self) -> None: ...
    def __pack__(self, obj: _IT, context: layer) -> None: ...
    def __size__(self, context: layer) -> int: ...
    def __type__(self) -> _CTypeDesc[_OT]: ...
    def __unpack__(self, context: layer) -> _OT: ...

class binaryexpr(_ContextLambda):
    expr: int
    lhs: Union[_ContextLambda, Any]
    rhs: Union[_ContextLambda, Any]
    def __init__(self, expr: int, lhs, rhs) -> None: ...
    def __add__(self, other): ...
    def __and__(self, other): ...
    def __call__(self, *args, **kwargs): ...
    def __floordiv__(self, other): ...
    def __invert__(self): ...
    def __lshift__(self, other): ...
    def __matmul__(self, *args, **kwargs): ...
    def __mod__(self, other): ...
    def __mul__(self, other): ...
    def __neg__(self): ...
    def __or__(self, other): ...
    def __pos__(self): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rand__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __rlshift__(self, other): ...
    def __rmatmul__(self, *args, **kwargs): ...
    def __rmod__(self, other): ...
    def __rmul__(self, other): ...
    def __ror__(self, other): ...
    def __rpow__(self, other): ...
    def __rrshift__(self, other): ...
    def __rshift__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __rxor__(self, other): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...
    def __xor__(self, other): ...

class builtinatom(catom[_IT, _OT]):
    def __init__(self) -> None: ...
    def __floordiv__(
        self, condition: Union[bool, _ContextLambda[bool]]
    ) -> condition[_IT, _OT]: ...
    def __getitem__(self, index: _LengthT) -> repeated[_IT, _OT]: ...
    def __matmul__(
        self, offset: Union[int, _CContextLambda[int]]
    ) -> atoffset[_IT, _OT]: ...
    def __rfloordiv__(
        self, other: Union[bool, _CContextLambda[bool]]
    ) -> condition[_IT, _OT]: ...
    def __rmatmul__(
        self, offset: Union[int, _CContextLambda[int]]
    ) -> atoffset[_IT, _OT]: ...
    def __rrshift__(self, other) -> switch: ...
    def __rshift__(self, other) -> switch: ...

class catom(atom[_IT, _OT]):
    def __init__(self, *args, **kwargs) -> None: ...
    def __pack__(self, obj: _IT, context: layer) -> None: ...
    def __pack_many__(self, obj: Collection[_IT], layer: layer) -> None: ...
    def __size__(self, context: layer) -> int: ...
    def __type__(self) -> Union[Type[_OT], str, NotImplementedType]: ...
    def __unpack__(self, context: layer) -> _OT: ...
    def __unpack_many__(
        self, context: layer, lengthinfo: lengthinfo
    ) -> Collection[_OT]: ...

class computed(builtinatom[_IT, _IT]):
    value: _IT
    def __init__(self, value: _IT) -> None: ...

class condition(builtinatom[Optional[_IT], Optional[_OT]]):
    atom: atom[_IT, _OT]
    condition: Union[bool, _ContextLambda[bool]]
    def __init__(
        self, condition: Union[bool, _ContextLambda[bool]], atom: atom[_IT, _OT]
    ) -> None: ...
    def is_enabled(self, context: layer) -> bool: ...
    def __set_byteorder__(self, byteorder: Endian) -> condition[_IT, _OT]: ...

class const(Generic[_IT], builtinatom[_IT, _IT]):
    atom: atom[_IT, _IT]
    value: _IT
    def __init__(self, atom: atom[_IT, _IT], value: _IT) -> None: ...
    def __set_byteorder__(self, endian: Endian) -> const[_IT, _IT]: ...

class cstring(builtinatom[str, str]):
    length: Union[_LengthT, atom[int, int]]
    encoding: str
    errors: str
    terminator: str
    keep_terminator: bool
    def __init__(
        self,
        length: Union[_LengthT, atom],
        encoding: str = ...,
        errors: str = ...,
        sep: str = ...,
        keep_terminator: bool = ...,
    ) -> None: ...

class enumeration(builtinatom[_IT, _IT]):
    atom: atom[_IT, _IT]
    default: Optional[_IT]
    enum_type: Type[_IT]
    members: Dict[str, _IT]
    def __init__(
        self,
        atom: atom[_IT, _IT],
        enum_type: Type[_IT],
        default: Optional[_IT] = ...,
    ) -> None: ...
    def __set_byteorder__(self, endian: Endian) -> enumeration[_IT]: ...

class fieldinfo:
    excluded: bool
    default: Any
    field: atom
    name: str
    def __init__(self, field: atom, excluded: bool = ...) -> None: ...

class layer(_ContextLike):
    parent: Optional[layer]
    path: str
    state: State
    def __init__(
        self,
        state: State,
        path: str = ...,
        parent: layer = ...,
    ) -> None: ...
    def __context_getattr__(self, path: str) -> Any: ...

class lazy(builtinatom[_IT, _OT]):
    always_lazy: bool
    fn: Callable[[], atom[_IT, _OT]]
    def __init__(
        self, fn: Callable[[], atom[_IT, _OT]], always_lazy: bool = ...
    ) -> None: ...
    def __set_byteorder__(self, endian: Endian) -> lazy[_IT, _OT]: ...

class lengthinfo: ...

class objlayer(layer):
    obj: Context
    def __init__(
        self, state: State, path: str = ..., parent: layer = ..., obj: Context = ...
    ) -> None: ...
    def __context_getattr__(self, path: str) -> Any: ...

class octetstring(builtinatom[bytes, bytes]):
    length: _LengthT
    def __init__(self, length: _LengthT) -> None: ...

class patom(atom[_IT, _OT]):
    def __init__(self) -> None: ...
    def __floordiv__(self, other): ...
    def __getitem__(self, index): ...
    def __matmul__(self, *args, **kwargs): ...
    def __rfloordiv__(self, other): ...
    def __rmatmul__(self, *args, **kwargs): ...
    def __rrshift__(self, other): ...
    def __rshift__(self, other): ...

class pstring(builtinatom[str, str]):
    atom: atom[str, str]
    encoding: str
    errors: str
    def __init__(
        self, atom: atom[str, str], encoding: str = ..., errors: str = ...
    ) -> None: ...
    def __set_byteorder__(self, byteorder: Endian) -> pstring: ...

class repeated(builtinatom[_IT, _OT]):
    atom: atom[_IT, _OT]
    length: _LengthT
    def __init__(self, atom: atom[_IT, _OT], length: _LengthT) -> None: ...
    def __set_byteorder__(self, byteorder: Endian) -> repeated[_IT, _OT]: ...

class seqlayer(layer):
    index: int
    length: int
    sequence: Collection
    def __init__(self, *args, **kwargs) -> None: ...

class string(builtinatom[str, str]):
    encoding: str
    errors: str
    length: _LengthT
    def __init__(self, length: _LengthT, encoding: str, errors: str = ...) -> None: ...

class switch(builtinatom):
    atom: atom
    cases: Dict[Any, atom]
    def __init__(self, *args, **kwargs) -> None: ...
    def get_next(self, *args, **kwargs): ...
    def __set_byteorder__(self, endian: Endian) -> None: ...

class unaryexpr:
    expr: int
    value: Any | _CContextLambda
    def __init__(self, *args, **kwargs) -> None: ...
    def __add__(self, other): ...
    def __and__(self, other): ...
    def __call__(self, *args, **kwargs): ...
    def __floordiv__(self, other): ...
    def __hash__(self) -> int: ...
    def __invert__(self): ...
    def __lshift__(self, other): ...
    def __matmul__(self, *args, **kwargs): ...
    def __mod__(self, other): ...
    def __mul__(self, other): ...
    def __neg__(self): ...
    def __or__(self, other): ...
    def __pos__(self): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rand__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __rlshift__(self, other): ...
    def __rmatmul__(self, *args, **kwargs): ...
    def __rmod__(self, other): ...
    def __rmul__(self, other): ...
    def __ror__(self, other): ...
    def __rpow__(self, other): ...
    def __rrshift__(self, other): ...
    def __rshift__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __rxor__(self, other): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...
    def __xor__(self, other): ...

def typeof(obj: atom): ...
def pack_into(__obj: _IT, __struct: atom[_IT, _OT], __io: IO, **globals) -> None: ...
def pack(__obj: _IT, __struct: atom[_IT, _OT], **globals) -> bytes: ...
def sizeof(obj: atom[_IT, _OT], globals: Optional[dict | Context] = ...) -> int: ...
def unpack(__io: IO | bytes, __struct: atom[_IT, _OT], **globals) -> _OT: ...

__all__ = [
    "Arch",
    "Bool",
    "Char",
    "Context",
    "ContextPath",
    "DefaultOptionType",
    "Endian",
    "Float",
    "Int",
    "InvalidDefaultType",
    "Option",
    "Padding",
    "State",
    "Struct",
    "VarInt",
    "atoffset",
    "atom",
    "binaryexpr",
    "builtinatom",
    "catom",
    "computed",
    "condition",
    "const",
    "cstring",
    "enumeration",
    "fieldinfo",
    "layer",
    "lazy",
    "lengthinfo",
    "objlayer",
    "octetstring",
    "patom",
    "pstring",
    "repeated",
    "seqlayer",
    "string",
    "switch",
    "unaryexpr",
    "typeof",
    "pack_into",
    "pack",
    "sizeof",
    "unpack",
    "BIG_ENDIAN",
    "DefaultOption",
    "FIELD_OPTIONS",
    "F_DYNAMIC",
    "F_SEQUENTIAL",
    "HOST_ARCH",
    "InvalidDefault",
    "LITTLE_ENDIAN",
    "NATIVE_ENDIAN",
    "STRUCT_OPTIONS",
    "S_DISCARD_CONST",
    "S_DISCARD_UNNAMED",
    "S_EVAL_ANNOTATIONS",
    "S_REPLACE_TYPES",
    "S_SLOTS",
    "S_UNION",
    "TYPE_MAP",
    "boolean",
    "char",
    "f16",
    "f32",
    "f64",
    "i128",
    "i16",
    "i24",
    "i32",
    "i64",
    "i8",
    "lsbvarint",
    "padding",
    "u128",
    "u16",
    "u24",
    "u32",
    "u64",
    "u8",
    "varint",
]
